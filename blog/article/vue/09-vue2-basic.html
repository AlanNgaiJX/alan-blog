<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue2知识点 | Alan&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="Alan Ngai's blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.9d2128d7.css" as="style"><link rel="preload" href="/blog/assets/js/app.f8f96e74.js" as="script"><link rel="preload" href="/blog/assets/js/4.6139eb27.js" as="script"><link rel="preload" href="/blog/assets/js/93.8f412530.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.dffdecc9.js"><link rel="prefetch" href="/blog/assets/js/10.892e108a.js"><link rel="prefetch" href="/blog/assets/js/11.085d6100.js"><link rel="prefetch" href="/blog/assets/js/12.2cc757ba.js"><link rel="prefetch" href="/blog/assets/js/13.0367244e.js"><link rel="prefetch" href="/blog/assets/js/14.b2f4d64c.js"><link rel="prefetch" href="/blog/assets/js/15.6ddece63.js"><link rel="prefetch" href="/blog/assets/js/16.20f6a985.js"><link rel="prefetch" href="/blog/assets/js/17.46d271c9.js"><link rel="prefetch" href="/blog/assets/js/18.17cfcf9c.js"><link rel="prefetch" href="/blog/assets/js/19.8cf46156.js"><link rel="prefetch" href="/blog/assets/js/2.82b35d59.js"><link rel="prefetch" href="/blog/assets/js/20.fd941f93.js"><link rel="prefetch" href="/blog/assets/js/21.c078e9c0.js"><link rel="prefetch" href="/blog/assets/js/22.5c0862e4.js"><link rel="prefetch" href="/blog/assets/js/23.c7f72733.js"><link rel="prefetch" href="/blog/assets/js/24.52fdd4f8.js"><link rel="prefetch" href="/blog/assets/js/25.368e2315.js"><link rel="prefetch" href="/blog/assets/js/26.5c63b142.js"><link rel="prefetch" href="/blog/assets/js/27.ddfcdb2d.js"><link rel="prefetch" href="/blog/assets/js/28.22865393.js"><link rel="prefetch" href="/blog/assets/js/29.e5fe1393.js"><link rel="prefetch" href="/blog/assets/js/30.d144fd1a.js"><link rel="prefetch" href="/blog/assets/js/31.65477877.js"><link rel="prefetch" href="/blog/assets/js/32.60115257.js"><link rel="prefetch" href="/blog/assets/js/33.2e871854.js"><link rel="prefetch" href="/blog/assets/js/34.34430d0e.js"><link rel="prefetch" href="/blog/assets/js/35.94e8bd08.js"><link rel="prefetch" href="/blog/assets/js/36.15cfbc42.js"><link rel="prefetch" href="/blog/assets/js/37.aa42156a.js"><link rel="prefetch" href="/blog/assets/js/38.5ca9e70e.js"><link rel="prefetch" href="/blog/assets/js/39.142bd374.js"><link rel="prefetch" href="/blog/assets/js/40.fd8875e4.js"><link rel="prefetch" href="/blog/assets/js/41.0b7b3a21.js"><link rel="prefetch" href="/blog/assets/js/42.a654a6e3.js"><link rel="prefetch" href="/blog/assets/js/43.8f99be13.js"><link rel="prefetch" href="/blog/assets/js/44.98e1be8b.js"><link rel="prefetch" href="/blog/assets/js/45.ca1df94b.js"><link rel="prefetch" href="/blog/assets/js/46.dd8a7912.js"><link rel="prefetch" href="/blog/assets/js/47.2772e960.js"><link rel="prefetch" href="/blog/assets/js/48.e4fa5e1e.js"><link rel="prefetch" href="/blog/assets/js/49.770f18dc.js"><link rel="prefetch" href="/blog/assets/js/5.f7cfe7f2.js"><link rel="prefetch" href="/blog/assets/js/50.c7ef5dad.js"><link rel="prefetch" href="/blog/assets/js/51.580b9035.js"><link rel="prefetch" href="/blog/assets/js/52.e41ad6ad.js"><link rel="prefetch" href="/blog/assets/js/53.9c19d216.js"><link rel="prefetch" href="/blog/assets/js/54.ba286cf6.js"><link rel="prefetch" href="/blog/assets/js/55.08c72493.js"><link rel="prefetch" href="/blog/assets/js/56.fa1f0725.js"><link rel="prefetch" href="/blog/assets/js/57.c74b80be.js"><link rel="prefetch" href="/blog/assets/js/58.795242e8.js"><link rel="prefetch" href="/blog/assets/js/59.b2f16dbe.js"><link rel="prefetch" href="/blog/assets/js/6.4cae87e7.js"><link rel="prefetch" href="/blog/assets/js/60.f14878b0.js"><link rel="prefetch" href="/blog/assets/js/61.63e7171c.js"><link rel="prefetch" href="/blog/assets/js/62.c3ce14af.js"><link rel="prefetch" href="/blog/assets/js/63.8ec67dc9.js"><link rel="prefetch" href="/blog/assets/js/64.6e0d59f5.js"><link rel="prefetch" href="/blog/assets/js/65.7d7773f1.js"><link rel="prefetch" href="/blog/assets/js/66.e50599ac.js"><link rel="prefetch" href="/blog/assets/js/67.c20e6566.js"><link rel="prefetch" href="/blog/assets/js/68.b1c96e66.js"><link rel="prefetch" href="/blog/assets/js/69.cfb92fc6.js"><link rel="prefetch" href="/blog/assets/js/7.b4691d0b.js"><link rel="prefetch" href="/blog/assets/js/70.6f48c532.js"><link rel="prefetch" href="/blog/assets/js/71.636c207f.js"><link rel="prefetch" href="/blog/assets/js/72.1ea2b8cc.js"><link rel="prefetch" href="/blog/assets/js/73.20462913.js"><link rel="prefetch" href="/blog/assets/js/74.71a5097a.js"><link rel="prefetch" href="/blog/assets/js/75.b683e142.js"><link rel="prefetch" href="/blog/assets/js/76.11e19ed4.js"><link rel="prefetch" href="/blog/assets/js/77.cd344360.js"><link rel="prefetch" href="/blog/assets/js/78.f5792878.js"><link rel="prefetch" href="/blog/assets/js/79.96db5de7.js"><link rel="prefetch" href="/blog/assets/js/8.c193a335.js"><link rel="prefetch" href="/blog/assets/js/80.f894adc9.js"><link rel="prefetch" href="/blog/assets/js/81.1ea3bfdd.js"><link rel="prefetch" href="/blog/assets/js/82.6a2b0465.js"><link rel="prefetch" href="/blog/assets/js/83.b5f5d1a9.js"><link rel="prefetch" href="/blog/assets/js/84.1ef51d9f.js"><link rel="prefetch" href="/blog/assets/js/85.e34a2a0c.js"><link rel="prefetch" href="/blog/assets/js/86.a77f0705.js"><link rel="prefetch" href="/blog/assets/js/87.99686b99.js"><link rel="prefetch" href="/blog/assets/js/88.d6d9246b.js"><link rel="prefetch" href="/blog/assets/js/89.85d91c07.js"><link rel="prefetch" href="/blog/assets/js/9.806164c7.js"><link rel="prefetch" href="/blog/assets/js/90.450f0b66.js"><link rel="prefetch" href="/blog/assets/js/91.90f432fe.js"><link rel="prefetch" href="/blog/assets/js/92.8c525bff.js"><link rel="prefetch" href="/blog/assets/js/94.bbc91217.js"><link rel="prefetch" href="/blog/assets/js/95.d8bd504b.js"><link rel="prefetch" href="/blog/assets/js/96.64953d8c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.9d2128d7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/imgs/favicon.svg" alt="Alan's blog" class="logo"> <span class="site-name can-hide">Alan's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/AlanNgaiJX" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/AlanNgaiJX" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/article/" aria-current="page" class="sidebar-link">总览</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/article/vue/01-vue-life-circle.html" class="sidebar-link">vue生命周期详解</a></li><li><a href="/blog/article/vue/02-keep-alive.html" class="sidebar-link">keep-alive详解</a></li><li><a href="/blog/article/vue/03-navigation-guards.html" class="sidebar-link">vue-router导航守卫详解</a></li><li><a href="/blog/article/vue/04-route-cache.html" class="sidebar-link">实现路由缓存</a></li><li><a href="/blog/article/vue/05-vuex.html" class="sidebar-link">vuex总结</a></li><li><a href="/blog/article/vue/06-vue-router.html" class="sidebar-link">vue-router总结</a></li><li><a href="/blog/article/vue/07-mvvm.html" class="sidebar-link">MVVM 模型</a></li><li><a href="/blog/article/vue/08-vue-key.html" class="sidebar-link">key的作用与原理</a></li><li><a href="/blog/article/vue/09-vue2-basic.html" aria-current="page" class="active sidebar-link">vue2知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vue的兼容情况" class="sidebar-link">vue的兼容情况</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vue的生命周期与简单介绍" class="sidebar-link">vue的生命周期与简单介绍</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#生命周期的实例方法" class="sidebar-link">生命周期的实例方法</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#指令" class="sidebar-link">指令</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#data" class="sidebar-link">data</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#watch" class="sidebar-link">watch</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#computed" class="sidebar-link">computed</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#动态绑定class的四种形态" class="sidebar-link">动态绑定class的四种形态</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#正确更新data中的数组" class="sidebar-link">正确更新data中的数组</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#正确更新data中的对象属性" class="sidebar-link">正确更新data中的对象属性</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#列表渲染的细节" class="sidebar-link">列表渲染的细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#列表渲染要指定唯一的key" class="sidebar-link">列表渲染要指定唯一的key</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#v-for-和-v-if-可以同时在一个元素上使用-但不推荐这么做。" class="sidebar-link">v-for 和 v-if 可以同时在一个元素上使用，但不推荐这么做。</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#混入" class="sidebar-link">混入</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#filter" class="sidebar-link">filter</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#组件间的传参" class="sidebar-link">组件间的传参</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#父子组件传参" class="sidebar-link">父子组件传参</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#兄弟组件传参" class="sidebar-link">兄弟组件传参</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#多层嵌套组件传参" class="sidebar-link">多层嵌套组件传参</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#更多野路子" class="sidebar-link">更多野路子</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vm-refs" class="sidebar-link">vm.$refs</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vm-parent" class="sidebar-link">vm.$parent</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vm-children" class="sidebar-link">vm.$children</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vm-root" class="sidebar-link">vm.$root</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#props" class="sidebar-link">props</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#scoped" class="sidebar-link">scoped</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#渲染时保留模板的html注释" class="sidebar-link">渲染时保留模板的html注释</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#重置data" class="sidebar-link">重置data</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#created-和-mounted中请求数据的区别" class="sidebar-link">created 和 mounted中请求数据的区别</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#组件命名规范" class="sidebar-link">组件命名规范</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#组件名的作用" class="sidebar-link">组件名的作用</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#递归组件" class="sidebar-link">递归组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#slot" class="sidebar-link">slot</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#过渡动画的实现方式" class="sidebar-link">过渡动画的实现方式</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#捕获组件的错误信息" class="sidebar-link">捕获组件的错误信息</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#vue-observable" class="sidebar-link">Vue.observable</a></li><li class="sidebar-sub-header"><a href="/blog/article/vue/09-vue2-basic.html#如何设置favicon" class="sidebar-link">如何设置favicon</a></li></ul></li><li><a href="/blog/article/vue/10-vue-cli.html" class="sidebar-link">vue cli知识点</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Arithmetic</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue的兼容情况"><a href="#vue的兼容情况" class="header-anchor">#</a> vue的兼容情况</h2> <ul><li>vue2不兼容ie8以下浏览器，因为vue的响应式原理基于es5的Object.defineProperty。</li> <li>vue3使用了 es6的 proxy ，全面抛弃ie。</li></ul> <h2 id="vue的生命周期与简单介绍"><a href="#vue的生命周期与简单介绍" class="header-anchor">#</a> vue的生命周期与简单介绍</h2> <ol><li>beforeCreate：实例创建前被调用；</li> <li>created：实例创建后被调用，完成数据观测，属性和方法的运算，watch/event事件回调，模板渲染成html前（vm.$el未定义）故数据初始化最好在这阶段完成；</li> <li>beforeMount：在$el挂载前被调用，相关的 render 函数首次被调用，期间将模块渲染成html,此时vm.$el还是未定义；</li> <li>mounted：在$el挂载后被调用，此时vm.$el可以调用，不能保证所有的子组件都挂载，要等视图全部更新完毕用vm.$nextTick();</li> <li>beforeUpdate：数据更新时调用;</li> <li>updated：数据更新后调用;</li> <li>activated：<!---->包裹的组件激活时调用；</li> <li>deactivated:<!---->包裹的组件离开时调用；</li> <li>beforeDestroy:实例销毁之前调用,此时实例仍然完全可用；</li> <li>destroyed：实例销毁之后调用,此时实例的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ol> <h2 id="生命周期的实例方法"><a href="#生命周期的实例方法" class="header-anchor">#</a> 生命周期的实例方法</h2> <ol><li>vm.$mount()，主动挂载vue实例到某个dom节点。</li> <li>vm.$forceUpdate()，强制Vue实例更新渲染，仅仅会影响本组件进入更新阶段。</li> <li>vm.$nextTick()，指定一个回调，在视图全部更新后执行回调，一般用来获取异步更新的dom节点。</li> <li>vm.$destory()，销毁一个实例，解除该实例与其他实例的链接，接触其时间监听。但要配合 dom 的 remove方法才能清除该实例所挂载的节点。</li></ol> <h2 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h2> <ol><li>v-show，</li></ol> <ul><li>切换元素的 display 属性。</li> <li>不可用在 template 上。</li></ul> <ol start="2"><li>v-if</li></ol> <ul><li>通过销毁和初始化的方式，控制组件和节点的显示。</li> <li>不适合用在频繁的显示和隐藏场景</li> <li>适合用在异步渲染的组件上</li> <li>可以用在template上</li> <li>对应还有 v-eles-if、v-else 指令</li></ul> <ol start="3"><li>v-for</li></ol> <ul><li>进行列表渲染，必须为每个单元设置唯一的key</li> <li>可以渲染 array、object、number、string等数据结构</li> <li>列表渲染对象时，是按Object.keys()的顺序的遍历，如果需要保证顺序需要转为array或者map数据结构。</li></ul> <ol start="4"><li>v-on</li></ol> <ul><li>用在 html 节点上，监听原生的事件</li> <li>用在组件上，监听组件的自定义事件</li> <li>用在组件上，添加 .native 修饰符，可监听组件根元素的原始事件</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>myVue</span> <span class="token attr-name">@click.native</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>d<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>myVue</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>.stop，对应 e.stopPropagation，阻止冒泡</li> <li>.prevent，对应 e.preventDefault，阻止默认事件</li> <li>.self，对应判断e.target是本身，仅点击本身的元素才触发</li> <li>.capture，在事件capture阶段触发</li> <li>.passive，在事件冒泡阶段触发</li> <li>.once，仅触发一次</li> <li>注!意!修饰符的顺序：@click.prevent.self 会阻止包括子节点的默认时间，而 @click.self.prevent 只会阻止元素自身的默认事件。</li> <li>event对象默认在第一个参数传入，也可以指定一个位置<code>@click=&quot;handleOpen(0, $event)&quot;</code></li> <li>v-on可以绑定多个事件，但只支持同样的修饰符。</li></ul> <ol start="5"><li>v-bind 动态绑定属性</li></ol> <ul><li>.sync可以进行属性的双向绑定</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:title'</span><span class="token punctuation">,</span> newTitle<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="6"><li>v-model</li></ol> <ul><li>实现双向数据绑定</li> <li>可以绑定在组件上，组件需配合作出这样的改造</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>model<span class="token operator">:</span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token string">'checked'</span><span class="token punctuation">,</span>
  event<span class="token operator">:</span> <span class="token string">'change'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
props<span class="token operator">:</span><span class="token punctuation">{</span>
  checked<span class="token operator">:</span> Boolean
<span class="token punctuation">}</span>
<span class="token comment">//更新数据的方法</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token string">'xxxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>.lazy 修饰符，绑定的事件从 inpu 改为change，即失去焦点或按下回车键时才触发。</li> <li>.number，保证用户输入的是数字</li> <li>.trim，字符串trim</li> <li>v-model其实是，<code>&lt;my-component :value=&quot;value&quot; @input=&quot;value=$event&quot;&gt;&lt;/my-component&gt;</code>的语法糖。</li></ul> <ol start="7"><li><p>v-text，输出字符串</p></li> <li><p>v-html</p></li></ol> <ul><li>输出 html 内容</li> <li>有 XSS 攻击风险，小心使用，不要显示任何用户提交的内容。</li> <li>XSS攻击是攻击客户端的方式，对客户端实施串改和偷取，传统有偷cookie，偷输入内容等。</li> <li>evel、postMessage等都有xss攻击隐患。</li></ul> <ol start="9"><li><p>v-once，只渲染组件一次，随后与diff算法无缘，不发生更新，是一种优化手段。</p></li> <li><p>v-cloak</p></li></ol> <ul><li>在js解析特别慢的时候，页面模板上可能会出现vue的变量名，如''</li> <li>配合css可以不显示变量名，[ v-clock ]{ display: none };</li></ul> <ol start="11"><li><p>v-pre，指定这个元素树跳过编译环节，如果这个树很大是值得这么做的，可以加快编译速度。</p></li> <li><p>v-slot</p></li></ol> <ul><li>插槽命令，用在 template 上</li> <li>v-slot:插槽名=&quot;props&quot;</li></ul> <h2 id="data"><a href="#data" class="header-anchor">#</a> data</h2> <p>为什么组件中的data必须用函数返回对象？
答：因为对象是引用类型，如果data是一个对象，组件复用时不同的实例都指向了同一个data对象，data容易被串改。在实例化组件时，使用一个工厂函数返回data对象就不会出现这个问题。</p> <h2 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h2> <ol><li>watch用来监听数据变化（来源于data 或 computed的属性 ）</li> <li>'a.b' 监听对象的某个属性</li> <li>deep 深度监听对象，小心使用，万一对象太大，且更新频繁，会很消耗性能</li> <li>immediate 侦听开始即调用</li></ol> <h2 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h2> <ul><li>计算属性主要解决了状态派生的问题，如果在模板中派生状态会变得非常恶心。</li> <li>计算属性基于响应式依赖进行缓存，只有相关依赖发生改变才会重新计算值，非常节省算力。</li> <li>get在读取数据时触发，也是有缓存的。set在设置数据时触发可以配合v-model使用。</li> <li>computed、methods、filter那些都不能是箭头函数，这样this是undefind。</li> <li>computed可以接收参数，做法是返回一个箭头函数</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>computed 和 watch的 区别
<ul><li>watch是监听数据变化，并触发响应的逻辑。computed是派生一个数据状态。</li> <li>watch没有缓存，computed有缓存。</li> <li>computed可以传入参数，watch不能。</li></ul></li> <li>computed 和 method的区别
<ul><li>计算属性基于响应式依赖进行更新，是有缓存的，而method随着组件重新渲染时都会再次执行函数，没有缓存。</li></ul></li></ul> <h2 id="动态绑定class的四种形态"><a href="#动态绑定class的四种形态" class="header-anchor">#</a> 动态绑定class的四种形态</h2> <ul><li>对象形态，<code>:class=&quot;{ active: actived , 'active-click': clicked &amp;&amp; actived }&quot;</code></li> <li>数组形态，<code>:class=&quot;[ actived ? 'active': '', clicked &amp;&amp; actived ? 'active-click' : '' ]&quot;</code></li> <li>数组+对象形态，<code>:class=&quot;[{active: actived}, { active-click: clicked &amp;&amp; actived }]&quot;</code></li> <li>计算属性</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//`:class=&quot;classOject &quot;`</span>
computed<span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token function">clasObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      active<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>actived <span class="token punctuation">,</span> 
      <span class="token string">'active-click'</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clicked <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>actived
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>同理styles也是差不多，但要注意属性驼峰命名。</li></ul> <h2 id="正确更新data中的数组"><a href="#正确更新data中的数组" class="header-anchor">#</a> 正确更新data中的数组</h2> <ul><li><p>使用变更数组的方法</p> <ul><li>push() pop() unshift() shift()</li> <li>reverse() sort() splice()</li></ul></li> <li><p>替换整个数组 <code>this.arr = newArr</code></p></li> <li><p>非法的更改：</p> <ul><li>使用index更改数组元素，如 <code>this.arr[0] = newItem</code>;使用this.$set(this.arr, 0, newItem)纠正；</li> <li>使用length修改数组长度,如 <code>this.arr.lengt = 0</code>;使用splice纠正；</li></ul></li></ul> <h2 id="正确更新data中的对象属性"><a href="#正确更新data中的对象属性" class="header-anchor">#</a> 正确更新data中的对象属性</h2> <ol><li>因为vue2使用 Object.defineProperty 劫持对象属性的方式完成数据监听。</li> <li>所以动态往对象添加或删除属性，需要用vm.$set、vm.$delete方法刷新劫持属性，才能使新增的对象属性才具有响应式。</li> <li>vue3使用 proxy的方式监听整个对象，甚至可以监听到属性的增删。</li></ol> <h2 id="列表渲染的细节"><a href="#列表渲染的细节" class="header-anchor">#</a> 列表渲染的细节</h2> <h3 id="列表渲染要指定唯一的key"><a href="#列表渲染要指定唯一的key" class="header-anchor">#</a> 列表渲染要指定唯一的key</h3> <p>key的作用是能让vue以更小的遍历代价更新视图。</p> <h3 id="v-for-和-v-if-可以同时在一个元素上使用-但不推荐这么做。"><a href="#v-for-和-v-if-可以同时在一个元素上使用-但不推荐这么做。" class="header-anchor">#</a> v-for 和 v-if 可以同时在一个元素上使用，但不推荐这么做。</h3> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>user in users<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>user.isActive<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>v-for的优先级比v-if高，所以，v-if会忽略渲染部分li。</li> <li>可以通过computed 配合 filter过滤出必须显示的li，这样遍历更高效。</li></ul> <h2 id="混入"><a href="#混入" class="header-anchor">#</a> 混入</h2> <ol><li>混入是vue复用逻辑的手段之一。</li> <li>如果组件间需要共享一份选项时（如data，method，computed等)，可使用mixin混入一份配置。</li> <li>混入分为全局混入和组件内混入两种方式。</li> <li>必须小心进行全局混入，因为这样每一个组件中都会混入了选项，包括第三方的组件。</li> <li>混入的选项与组件内的选项将会合并：</li></ol> <ul><li>data选项发生冲突时，以组件内的data优先。</li> <li>methods、components、directives等冲突时，以组件内的优先。</li> <li>同名钩子都会触发，且混入的钩子优先触发</li> <li>watch相同的属性时，混入的watch先触发</li> <li>可以在vue的全局配置中配置自定义的混入策略</li></ul> <h2 id="filter"><a href="#filter" class="header-anchor">#</a> filter</h2> <ul><li>filter通常用于一些常见的文本格式化，如单位、前缀、后缀等。</li> <li>filter跟computed虽然很像，他们都接收输入以及参数，且必须返回一个结果。</li> <li>但是filter的计算不依赖任何响应式数据，且没有缓存机制。</li> <li>filter作为一种纯函数使用，而computed以值的形式存在，而且还有set方法。</li> <li>filter可以全局注册和局部注册。</li></ul> <h2 id="组件间的传参"><a href="#组件间的传参" class="header-anchor">#</a> 组件间的传参</h2> <h3 id="父子组件传参"><a href="#父子组件传参" class="header-anchor">#</a> 父子组件传参</h3> <ol><li>父组件通过props向子组件传参。</li> <li>通过 自定义事件 和 $emit，可以完成子组件向父组件传参。</li> <li>非标准的做法还有，向子组件传递一个回调函数，向子组件传递对象和数组等。</li></ol> <h3 id="兄弟组件传参"><a href="#兄弟组件传参" class="header-anchor">#</a> 兄弟组件传参</h3> <p>简单情况下，可以将数据管理的工作提升到兄弟组件的父级组件进行，然后为各个兄弟组件分发数据。</p> <h3 id="多层嵌套组件传参"><a href="#多层嵌套组件传参" class="header-anchor">#</a> 多层嵌套组件传参</h3> <ol><li>在顶层组件中使用provide，子组件中使用inject可以完成组件的跨级通信。但这样底层的兄弟组件不好通信。</li> <li>此时多个组件间可以维护一个订阅发布模式的eventBus，进行通信。这种处理方式在组件库开发中是常见的。</li> <li>更复杂的业务数据维护，多个组件依赖共同状态，且多个组件具有共同改变状态的行为时，用vuex。</li></ol> <h3 id="更多野路子"><a href="#更多野路子" class="header-anchor">#</a> 更多野路子</h3> <ol><li>在组件内使用$root、$parent、$children等方式进行组件间通信</li> <li>不推荐这么做，这样组件太耦合。</li></ol> <h2 id="vm-refs"><a href="#vm-refs" class="header-anchor">#</a> vm.$refs</h2> <ul><li>ref注册在dom元素上，<code>this.$refs.xxx</code>获取的是dom元素。</li> <li>ref注册在组件上,<code>this.$refs.xxx</code>获取的是组件实例。</li> <li>ref注册在v-for的元素上，<code>this.$refs.xxx</code>获取的是一个dom数组或组件数组。</li></ul> <h2 id="vm-parent"><a href="#vm-parent" class="header-anchor">#</a> vm.$parent</h2> <p>获取该组件的父组件实例</p> <h2 id="vm-children"><a href="#vm-children" class="header-anchor">#</a> vm.$children</h2> <p>获取该组件的子组件数组</p> <h2 id="vm-root"><a href="#vm-root" class="header-anchor">#</a> vm.$root</h2> <p>获取组件的根组件实例</p> <h2 id="props"><a href="#props" class="header-anchor">#</a> props</h2> <ol><li>prop的验证类型有String、Number、Boolean、Array、Object、Date、Function、Symbol,此外还可以是一个自定义的构造函数，如</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Personnel</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span><span class="token punctuation">{</span>
        wokrer<span class="token operator">:</span>Personnel
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="2"><li><p>多个验证类型使用<code>[String, Number]</code>的形式，Object和Array的默认值使用工厂函数返回。</p></li> <li><p>props必须是单向传递的，即组件的props更新会影响子级，子组件不能改变prop；否则多个子组件都能在其内部更新父组件的数据，会导致数据流变得混乱。</p></li> <li><p>子组件修改prop时，vue会发出警告，但不会报错。所以props对象或数组时尽量进行深复制。使用props数据时最好使用计算属性返回一下再使用。</p></li></ol> <h2 id="scoped"><a href="#scoped" class="header-anchor">#</a> scoped</h2> <ul><li>vue通过在DOM结构以及css样式上加上唯一的标记<code>data-v-xxxxxx</code>，保证唯一，达到组件内的样式私有化，不污染全局的作用。</li> <li>但这样做有个弊端，属性选择器提升了该组件样式的权重，使得难以在组件外修改这个组件样式，尤其在组件库开发这对于组件的使用者来说是致命的。他们只能通过提升自己样式的权重来覆盖组件样式（如叠加选择器，使用!import、使用deep等），如</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.father-div /deep/ .child-div</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">// 会编译成
.father-div[data-v-b45036b2] .child-div</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="渲染时保留模板的html注释"><a href="#渲染时保留模板的html注释" class="header-anchor">#</a> 渲染时保留模板的html注释</h2> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">comments</span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="重置data"><a href="#重置data" class="header-anchor">#</a> 重置data</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="created-和-mounted中请求数据的区别"><a href="#created-和-mounted中请求数据的区别" class="header-anchor">#</a> created 和 mounted中请求数据的区别</h2> <p>从父组件先创建（等待子组件完成挂载后）后挂载的角度看，在created上发起请求确实抢先了一步时机，节省了等待子组件挂载的时间。</p> <h2 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h2> <h3 id="组件命名规范"><a href="#组件命名规范" class="header-anchor">#</a> 组件命名规范</h3> <ol><li>name和标签名使用 kebab-case</li> <li>组件变量名使用大写驼峰式 KebabCase</li></ol> <h3 id="组件名的作用"><a href="#组件名的作用" class="header-anchor">#</a> 组件名的作用</h3> <ol><li>递归组件时，组件调用自身使用；</li> <li>用is特殊特性和component内置组件标签时使用；</li> <li>keep-alive内置组件标签中include 和exclude属性中使用。</li></ol> <h3 id="递归组件"><a href="#递归组件" class="header-anchor">#</a> 递归组件</h3> <ol><li>递归组件是组件调用组件自身，</li> <li>场景：多级菜单，展示树状结构数据等。</li> <li>递归组件必须配合v-if终止递归，否则会死循环。</li></ol> <h2 id="slot"><a href="#slot" class="header-anchor">#</a> slot</h2> <ol><li>插槽主要应用在复用度较高的组件上，为组件提供嵌入功能模块的功能。</li> <li>它很像props，但传入的不是属性，而是结构。</li> <li>站在props的角度来说，props解决了数据上的耦合问题。</li> <li>slot则是解决结构上耦合的问题。</li></ol> <h2 id="过渡动画的实现方式"><a href="#过渡动画的实现方式" class="header-anchor">#</a> 过渡动画的实现方式</h2> <ol><li>指定过渡类名</li></ol> <ul><li>v-enter</li> <li>v-enter-active</li> <li>v-enter-to</li> <li>v-leave</li> <li>v-leave-active</li> <li>v-leave-to</li></ul> <ol start="2"><li>使用js钩子</li></ol> <ul><li>@before-enter</li> <li>@enter</li> <li>@after-enter</li> <li>@enter-cancelled</li> <li>@before-leave</li> <li>@leave</li> <li>@after</li> <li>@leave-cancelled</li></ul> <h2 id="捕获组件的错误信息"><a href="#捕获组件的错误信息" class="header-anchor">#</a> 捕获组件的错误信息</h2> <ol><li>使用errorCapture 组件钩子，可以捕获组件及子组件的错误信息。</li> <li>使用 Vue.config.errorHandler, 全局捕获vue实例的错误。</li></ol> <h2 id="vue-observable"><a href="#vue-observable" class="header-anchor">#</a> Vue.observable</h2> <ol><li>他对应vue3 就是 reactive方法，可以让一个对象具有相应性。</li> <li>响应式数据可以作为状态分发给组件使用，跟一个简版的vuex一样。</li> <li>实际上在组件实例化的时候data都使用了这个方法从而成为响应式数据。</li></ol> <h2 id="如何设置favicon"><a href="#如何设置favicon" class="header-anchor">#</a> 如何设置favicon</h2> <ol><li>静态配置 <code>&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</code></li> <li>动态配置</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;&quot;&gt;</span>
<span class="token keyword">import</span> browserImg <span class="token keyword">from</span> <span class="token string">'images/kong.png'</span><span class="token punctuation">;</span><span class="token comment">//为favicon的默认图片</span>
<span class="token keyword">const</span> imgurl <span class="token operator">=</span><span class="token string">'后端传回来的favicon.ico的线上地址'</span>
<span class="token keyword">let</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'link[type=&quot;image/png&quot;]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>imgurl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    link<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">,</span> imgurl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    link<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">,</span> browserImg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/article/vue/08-vue-key.html" class="prev">
        key的作用与原理
      </a></span> <span class="next"><a href="/blog/article/vue/10-vue-cli.html">
        vue cli知识点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.f8f96e74.js" defer></script><script src="/blog/assets/js/4.6139eb27.js" defer></script><script src="/blog/assets/js/93.8f412530.js" defer></script>
  </body>
</html>
